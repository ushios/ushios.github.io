[実践ハイパフォーマンスMySQL](https://www.oreilly.co.jp/books/9784873116389/) memo
==============================


MySQLのアーキテクチャと歴史
---------------------------

### 並行性・トランザクション

- テーブルロック、行ロック。オーバーヘッドは行ロックのほうが大きい。
- 一般に分離レベルが低いほど並行性が高くなり、オーバーヘッドが低い

----

- [トランザクション分離レベル](https://ja.wikipedia.org/wiki/%E3%83%88%E3%83%A9%E3%83%B3%E3%82%B6%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3%E5%88%86%E9%9B%A2%E3%83%AC%E3%83%99%E3%83%AB)
- [MySQLでトランザクションの4つの分離レベルを試す](http://d.hatena.ne.jp/fat47/touch/20140212/1392171784)

- READ UNCOMMITTED
  - コミットして無いのも他のトランザクションから読める
- READ COMMITTED
  - コミットしないと他のトランザクションから読めない
- REPEATABLE READ
  - 同じトランザクションでのそれ以降の読み取りは「同じに見える」ことが保証されるが、理論上ファントムリードが発生する。MySQLのデフォルト
- SERIALIZABLE
  - 最も高いレベルの分離。競合が起こら無いように、トランザクションを強制的に順序付ける


- [MVCC](https://ja.wikipedia.org/wiki/MultiVersion_Concurrency_Control)は `READ COMMITTED` と `REPEATABLE READ` のみが対応。
- [InnoDB のトランザクションモデルおよびロック](https://dev.mysql.com/doc/refman/5.6/ja/innodb-transaction-model.html)

----
  

MySQLのベンチマーク
---------------------




サーバーのパフォーマンスのプロファイリング
--------------------------------------

- [pt-query-digest](https://www.percona.com/doc/percona-toolkit/2.2/pt-query-digest.html)がでクエリログ分析


スキーマとデータ型の最適化
-------------------------

- 列の数が多すぎる
  - MyISAMとInnodbの間で行変換・列変換でCPUを食う
- NULLを極力減らす


### 1行カウンタテーブルについて

```
CREATE TABLE hit_counter (cnt int unsigned not null) ENGINE=InnoDB;
```
更新

```
UPDATE hit_counter SET cnt = cnt + 1;
```

ミューテックス代わりになってトランザクションが直列化（シリアライズ）する



インデックスによるパフォーマンスの向上
-----------------------------------

### ハッシュインデックスについて

- 明示的なハッシュインデックスをサポートするのはMemoryストレージエンジンだけ
- `=`,`IN()`, `<=>`演算子を使用する等値比較のみサポートする。 `price > 100`などの範囲クエリを高速化はできない

#### 列の分離

列の分離はその列が式の一部であってはならない。

```
SELECT actor_id FROM sakila.actor WHERE actor_id + 1 = 5;
```

```
SELECT ... WHERE TO_DAYS(CURRENT_DATE) - TO_DAYS(date_col) <= 10;
```


### インデックスによるパフォーマンスの向上

```
WHERE A IN('a', 'b,' 'c') 
AND B IN(1, 2)
AND C IN('A', 'B', 'C')
```

上記クエリは、 3 * 2 * 3 = 12 通りの組み合わせに変換されるため、チェック数が多くなる。オプティマイザの処理にも時間がかかる

### ソートの最適化
- 件数が多いときの `order` `limit`の組み合わせには遅延結合が良い

`6.7.2JOINクエリの最適化`, `6.7.5 LIMIT と OFFSET の最適化`短いから読んでね


クエリのパフォーマンスの最適化
--------------------------

- `IN()`句の中にサブクエリを書くと、相関サブクエリになりやすい。その場合joinのほうが良い。
- `GROUP_CONCAT()`で`IN()`に渡す値を明示的に生成する方法もある


MySQLの高度な機能
---------------

サーバー設定の最適化
----------------

オペレーティングシステムとハードウェアの最適化
--------------------------------------

レプリケーション
-------------

`10.5.2 レプリカが遅れ始める状況（p.509）`大事そう。

### 10.6.2 レプリケーション遅延の計測

Seconds_behind_masterは常に正確であるとは限らない

- バイナリログに記録されたタイムスタンプと比較するため、クエリ処理しないと遅延を報告できない
- レプリカプロセスが実行されてない場合NULL
- 何らかのエラーでレプリケーションが無効になるとエラーではなくて、0
- レプリケーションプロセスが実行されてたとしてもレプリカ遅延を計算できないことがある。その場合0かNULL
- トランザクションに時間がかかってる場合報告が遅延する。トランザクションが１時間の場合、コミット後に１時間を報告し、その後すぐ0

ハートビートレコードで解決できる



MySQLのスケーリング
----------------





高可用性
-------

クラウドでのMySQL
---------------

アプリケーションレベルの最適化
-------------------------

バックアップとリカバリ
-------------------

MySQLユーザーのためのツール
------------------------


